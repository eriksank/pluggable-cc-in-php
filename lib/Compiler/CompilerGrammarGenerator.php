<?php
/*
        The compiler bison grammar generator

	Phnom Penh, Cambodia, January 2012
	Written by Erik Poupaert, erik@sankuru.biz
	Licensed under the LGPL
*/

require_once('Plugins/CompilerPluginLoader.php');
require_once('Plugins/ICompilerSemanticPlugin.php');
require_once('Plugins/CompilerSemanticPluginBinaryOperator.php');
require_once('Plugins/CompilerSemanticPluginOperand.php');

class CompilerGrammarGenerator
{
        //data collected
        var $tokens=null;
        var $rules=null;
        var $priorities=null;
        var $expectedShiftReduceConflicts=null;

        //plugins
        var $semanticPlugins=null;

        //current plugin
        var $currentSemanticPlugin=null;

        function __construct()
        {
                $this->tokens=array();
                $this->rules=array();
                $this->priorities=array();
                $this->expectedShiftReduceConflicts=array();
                compilerLoadSemanticPlugins($this);
        }

        function currentPluginName()
        {
                if($this->currentSemanticPlugin!=null)
                        return get_class($this->currentSemanticPlugin);
                else return 'null';
        }

        function addToken($symbol)
        {
                $this->tokens[$symbol]=array(
                                        'plugin'=>$this->currentPluginName(),
                                        'symbol'=>$symbol
                                        );
        }

        function addPriority($symbol,$associativity,$priority)
        {
                $this->priorities[]=array(
                                'plugin'=>$this->currentPluginName(),
                                'symbol'=>$symbol,
                                'associativity'=>$associativity,
                                'level'=>$priority
                        );
        }

        function addExpectedShiftReduceConflicts($number)
        {
                $this->expectedShiftReduceConflicts[]=array(
                                'plugin'=>$this->currentPluginName(),
                                'number'=>$number
                        );
        }

        function addGrammarRule($rule)
        {
                $this->rules[]=array(
                                'plugin'=>$this->currentPluginName(),
                                'rule'=>$rule
                        );
        }

        function collectData()
        {
                foreach($this->semanticPlugins as $this->currentSemanticPlugin)
                {
                        $this->currentSemanticPlugin->onGeneratingGrammar($this);
                }
        }

        function bisonTokenDefinition($token)
        {
                $plugin=$token['plugin'];
                $symbol=$token['symbol'];
                $line=sprintf("%%token %-15s /* %-15s */\n",$symbol,$plugin);
                return $line;
        }

        function bisonTokenDefinitions()
        {
                $buffer="\n/* Tokens generated by semantic plugins   */\n\n";
                foreach($this->tokens as $token)
                {
                        $buffer.=$this->bisonTokenDefinition($token);
                }
                return $buffer;
        }


        function bisonRuleDefinition($rule)
        {
                $plugin=$rule['plugin'];
                $ruleDef=$rule['rule'];
                $line=sprintf("/* %-15s */   %s ;\n",$plugin,$ruleDef);
                return $line;
        }

        function bisonRuleDefinitions()
        {
                $buffer="\n/* Rules generated by semantic plugins   */\n\n";
                foreach($this->rules as $rule)
                {
                        $buffer.=$this->bisonRuleDefinition($rule);
                }
                return $buffer;
        }

        function bisonPriorityLevel($priorityLevel,$associativity)
        {       
                $buffer='';

                foreach($this->priorities as $priority)
                {
                        if($priority['associativity']==$associativity && $priority['level']==$priorityLevel)
                        {
                                if($buffer=='') $buffer="%$associativity ";
                                $buffer.=$priority['symbol'].sprintf(" /* %s */ ",$priority['plugin']);
                        }
                }
                if($buffer!='') $buffer.="\n";

                return $buffer;
        }

        function minimumPriority()
        {
                if(count($this->priorities)>0)
                {
                        $priority=$this->priorities[0];
                        $minPriority=$priority['level'];
                        foreach($this->priorities as $priority)
                        {
                                if($priority['level']<$minPriority)
                                        $minPriority=$priority['level'];
                        }        
                        return $minPriority;
                }
                else
                {
                        return 0;
                }
        }

        function maximumPriority()
        {
                if(count($this->priorities)>0)
                {
                        $maxPriority=$this->priorities[0]['level'];
                        foreach($this->priorities as $priority)
                        {
                                if($priority['level']>$maxPriority)
                                        $maxPriority=$priority['level'];
                        }        
                        return $maxPriority;
                }
                else
                {
                        return 0;
                }
        }


        function bisonPriorityDefinitions()
        {
                $buffer="\n/* Priorities generated by semantic plugins   */\n\n";        
                $prioMin=$this->minimumPriority();
                $prioMax=$this->maximumPriority();
                for($i=$prioMin; $i<=$prioMax; $i++)
                {
                        $line=$this->bisonPriorityLevel($i,'left');
                        if($line!='') $buffer.=$line;
                        $line=$this->bisonPriorityLevel($i,'right');
                        if($line!='') $buffer.=$line;
                        $line=$this->bisonPriorityLevel($i,'nonassoc');
                        if($line!='') $buffer.=$line;
                }
                return $buffer;
        }

        function bisonExpectedShiftReduceConflicts()
        {
                $conflictLevel=0;
                $comment='';
                foreach($this->expectedShiftReduceConflicts as $expectedShiftReduceConflict)
                {
                        $plugin=$expectedShiftReduceConflict['plugin'];
                        $number=$expectedShiftReduceConflict['number'];
                        $conflictLevel+=$number;
                        $comment.=sprintf(" /* %s:%d */ ",$plugin,$number);
                }
                if($conflictLevel>0)
                {
                        $buffer="%expect $conflictLevel $comment\n";
                }
                else
                {
                        $buffer='';
                }
                return $buffer;
        }

        function expandTemplate()
        {
                $filePath=dirname(__FILE__).'/grammar.template.y';
                $text=file_get_contents($filePath);

                //replace placeholder for token definitions
                $regex='-'.preg_quote('//{tokens}//').'-';
                $text=preg_replace($regex,$this->bisonTokenDefinitions(),$text);

                //replace placeholder for rule definitions
                $regex='-'.preg_quote('//{rules}//').'-';
                $text=preg_replace($regex,$this->bisonRuleDefinitions(),$text);

                //replace placeholder for priority definitions
                $regex='-'.preg_quote('//{priorities}//').'-';
                $text=preg_replace($regex,$this->bisonPriorityDefinitions(),$text);

                //replace placeholder for expected shift/reduce conflicts
                $regex='-'.preg_quote('//{conflicts_expected}//').'-';
                $text=preg_replace($regex,$this->bisonExpectedShiftReduceConflicts(),$text);

                return $text;
        }

        function output()
        {
                $filePath=dirname(__FILE__).'/grammar.y';
                file_put_contents($filePath,$this->expandTemplate());
        }
}
?>

