/*
        The template bison grammar

	Phnom Penh, Cambodia, January 2012
	Written by Erik Poupaert, erik@sankuru.biz
	Licensed under the LGPL
*/
%token BRACKET_LEFT BRACKET_RIGHT

/* Tokens generated by semantic plugins   */

%token CONTINUE        /* _Continue       */
%token MODULO          /* _Modulo         */
%token TRUE            /* _True           */
%token GT              /* _GreaterThan    */
%token CONCAT          /* _Concat         */
%token IDENTIFIER      /* _Identifier     */
%token DO              /* _DoWhile        */
%token MINUS           /* _Minus          */
%token GE              /* _GreaterOrEqual */
%token SWITCH          /* _Switch         */
%token COLON           /* _Switch         */
%token CASE            /* _Switch         */
%token DEFAULT         /* _Switch         */
%token COMMA           /* _FunctionCall   */
%token NUMBER          /* _Number         */
%token PLUS            /* _Plus           */
%token CBRACKET_LEFT   /* _Block          */
%token CBRACKET_RIGHT  /* _Block          */
%token EXPONENTIATE    /* _Exponentiate   */
%token LT              /* _LessThan       */
%token LE              /* _LessOrEqual    */
%token IF              /* _If             */
%token ELSE            /* _If             */
%token FOR             /* _For            */
%token STRING          /* _String         */
%token WHILE           /* _While          */
%token DIVIDE          /* _Divide         */
%token ASSIGN          /* _Assign         */
%token TYPE_BOOL       /* _Cast           */
%token TYPE_INT        /* _Cast           */
%token TYPE_FLOAT      /* _Cast           */
%token TYPE_STRING     /* _Cast           */
%token SEMICOLON       /* _SemiColon      */
%token NULL            /* _Null           */
%token EQ              /* _Equals         */
%token AND             /* _And            */
%token FALSE           /* _False          */
%token MULTIPLY        /* _Multiply       */
%token OR              /* _Or             */
%token BREAK           /* _Break          */
%token NE              /* _NotEqual       */



/* Priorities generated by semantic plugins   */

%left ASSIGN /* _Assign */ 
%left CAST /* _Cast */ 
%left NOT /* _Not */ AND /* _And */ OR /* _Or */ 
%left GT /* _GreaterThan */ GE /* _GreaterOrEqual */ LT /* _LessThan */ LE /* _LessOrEqual */ EQ /* _Equals */ NE /* _NotEqual */ 
%left MINUS /* _Minus */ PLUS /* _Plus */ 
%left MODULO /* _Modulo */ DIVIDE /* _Divide */ MULTIPLY /* _Multiply */ 
%left CONCAT /* _Concat */ 
%left UNARY /* _UnaryMinus */ 
%right EXPONENTIATE /* _Exponentiate */ 


%expect 1  /* _If:1 */ 


%%
/* the following rules are the basic rules for a simple expression parser */

script: statements;
script : ;
statements: statements statement;
statements: statement;

statement: expression_statement;
expression_statement: expression SEMICOLON;
expression: BRACKET_LEFT expression BRACKET_RIGHT;

/* Rules generated by semantic plugins   */

/* _Not            */   expression: NOT expression ;
/* _Continue       */   statement: continue_statement ;
/* _Continue       */   continue_statement: CONTINUE SEMICOLON ;
/* _Modulo         */   expression: expression MODULO expression ;
/* _True           */   expression: TRUE ;
/* _GreaterThan    */   expression: expression GT expression ;
/* _Concat         */   expression: expression CONCAT expression ;
/* _Identifier     */   expression: IDENTIFIER ;
/* _DoWhile        */   statement: do_while_statement ;
/* _DoWhile        */   do_while_statement: do_prefix block WHILE BRACKET_LEFT expression BRACKET_RIGHT SEMICOLON ;
/* _DoWhile        */   do_prefix: DO ;
/* _Minus          */   expression: expression MINUS expression ;
/* _GreaterOrEqual */   expression: expression GE expression ;
/* _Switch         */   statement: switch_statement ;
/* _Switch         */   switch_statement: switch_prefix switch_condition CBRACKET_LEFT switch_options CBRACKET_RIGHT ;
/* _Switch         */   switch_statement: switch_prefix switch_condition CBRACKET_LEFT CBRACKET_RIGHT ;
/* _Switch         */   switch_prefix: SWITCH ;
/* _Switch         */   switch_condition: BRACKET_LEFT expression BRACKET_RIGHT ;
/* _Switch         */   switch_options: switch_options switch_option ;
/* _Switch         */   switch_options: switch_option ;
/* _Switch         */   switch_option: switch_case_option ;
/* _Switch         */   switch_option: switch_default_option ;
/* _Switch         */   switch_case_option: case_prefix case_expression COLON statements ;
/* _Switch         */   case_prefix: CASE ;
/* _Switch         */   case_expression: expression ;
/* _Switch         */   switch_default_option: default_prefix COLON statements ;
/* _Switch         */   default_prefix: DEFAULT ;
/* _FunctionCall   */   expression: function_expression ;
/* _FunctionCall   */   function_expression: IDENTIFIER BRACKET_LEFT arguments BRACKET_RIGHT ;
/* _FunctionCall   */   arguments: arguments COMMA argument ;
/* _FunctionCall   */   arguments: argument ;
/* _FunctionCall   */   arguments:  ;
/* _FunctionCall   */   argument: expression ;
/* _Number         */   expression: NUMBER ;
/* _Plus           */   expression: expression PLUS expression ;
/* _Block          */   block: statement ;
/* _Block          */   block: CBRACKET_LEFT block_statements CBRACKET_RIGHT ;
/* _Block          */   block: CBRACKET_LEFT CBRACKET_RIGHT ;
/* _Block          */   block_statements: block_statements block_statement ;
/* _Block          */   block_statements: block_statement ;
/* _Block          */   block_statement: statement ;
/* _Exponentiate   */   expression: expression EXPONENTIATE expression ;
/* _LessThan       */   expression: expression LT expression ;
/* _LessOrEqual    */   expression: expression LE expression ;
/* _If             */   statement: if_statement ;
/* _If             */   if_statement: if_clause else_clause ;
/* _If             */   if_clause: if_condition block ;
/* _If             */   if_condition: IF BRACKET_LEFT expression BRACKET_RIGHT ;
/* _If             */   else_clause: ELSE block ;
/* _If             */   else_clause:  ;
/* _For            */   statement: for_statement ;
/* _For            */   for_statement: for_clause for_block ;
/* _For            */   for_clause: FOR BRACKET_LEFT for_init_statements SEMICOLON for_condition SEMICOLON for_next_statements BRACKET_RIGHT ;
/* _For            */   for_init_statements: for_statements ;
/* _For            */   for_next_statements: for_statements ;
/* _For            */   for_statements: for_statements COMMA expression ;
/* _For            */   for_statements: expression ;
/* _For            */   for_statements:  ;
/* _For            */   for_condition: for_expression ;
/* _For            */   for_expression: expression ;
/* _For            */   for_expression: ;
/* _For            */   for_block: block ;
/* _String         */   expression: STRING ;
/* _While          */   statement: while_statement ;
/* _While          */   while_statement: while_clause block ;
/* _While          */   while_clause: while_prefix BRACKET_LEFT expression BRACKET_RIGHT ;
/* _While          */   while_prefix: WHILE ;
/* _Divide         */   expression: expression DIVIDE expression ;
/* _Assign         */   expression: expression ASSIGN expression ;
/* _Cast           */   expression: cast expression %prec CAST ;
/* _Cast           */   cast: BRACKET_LEFT type_name BRACKET_RIGHT ;
/* _Cast           */   type_name: TYPE_BOOL ;
/* _Cast           */   type_name: TYPE_INT ;
/* _Cast           */   type_name: TYPE_FLOAT ;
/* _Cast           */   type_name: TYPE_STRING ;
/* _Null           */   expression: NULL ;
/* _Equals         */   expression: expression EQ expression ;
/* _And            */   expression: expression AND expression ;
/* _False          */   expression: FALSE ;
/* _Multiply       */   expression: expression MULTIPLY expression ;
/* _Or             */   expression: expression OR expression ;
/* _Break          */   statement: break_statement ;
/* _Break          */   break_statement: BREAK SEMICOLON ;
/* _NotEqual       */   expression: expression NE expression ;
/* _UnaryMinus     */   expression: MINUS expression %prec UNARY ;

%%

